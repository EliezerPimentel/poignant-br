    - >
        Oh, e mais uma coisa sobre o @dup@.  Algumas coisas não podem ser "dupadas".  Números, por exemplo.  
        Símbolos (que se parecem com @:morte@) são idênticos quando grafados iguais.  Assim como números.


        Além disso, algumas variáveis especiais: @nil@, @true@, @false@.  Estas são coisas que o Ruby não vai
        te deixar alterar, então não faz sentido copiar mesmo.  Quero dizer, imagine se você pudesse mudar o @false@
        para que seja @true@.  A coisa toda vira uma mentira.


        Talvez o *Aspecto Confuso No. 3* seja um simples.  Estou usando aquelas chaves na string. 
        Estou tratando a como se ela fosse um Array ou Hash.  Eu posso fazer isso.  Porque strings
        têm um método @[]@.


        Quando usadas numa string, as chaves vão extrair parte daquela string.  Mais uma vez,
        espaço para as pás da empilhadeira. A string é como uma longa prateleira e a empilhadeira
        tira os pedaços da string.


        Dentro das chaves, nós passamos o _index (índice)_.  É a etiqueta que colocamos entre as pás,
        onde o trabalhador pode vê-las.  Quando o assunto são strings, podemos usar vários objetos como
        índices.
        

        <pre>
         str = "Uma string é uma longa prateleira de letras e espaços."
         puts str[0]       # imprime 85 (o código do caracter 'U')
         puts str[0..-1]   # imprime 'Uma string é uma longa prateleira de letras e espaços.'
         puts str[1..-2]   # imprime 'ma string é uma longa prateleira de letras e espaços'
         puts str[1, 3]    # imprime 'ma '
         puts str['prateleira'] # imrpime 'shelf'
        </pre>


        Tudo bem, o último *Aspecto Confuso No. 4*: este método pode ser enviado a um loop sem fim.
        Você pode dar uma string para este método que vai fazer com que ele trave e nunca mais volte.
        Dê uma olhada no método.  Você consegue jogar um graveto que trave o loop?


        <pre>
         def limpar_murmurios_de( frase )
           unless frase.respond_to? :include?
             raise ArgumentError, 
              "não posso limpar os múrmurios de um(a) #{ frase.class }"
           end
           frase = frase.dup
           while frase.include? '('
             abre = frase.index( '(' )
             fecha = frase.index( ')', abre )
             frase[abre..fecha] = '' if fecha
           end
           frase
         end
        </pre>


        Aqui, entorte o graveto antes de jogá-lo.


        <pre>
         graveto = "Aqui está uma ( curva."
         limpar_murmurios_de( graveto )
        </pre>


        Por que o método trava?  Bem, o loop @while@ espera até que todos os parênteses abertos se 
        acabem antes de parar de looping.  E ele só modifica um parêntese aberto que tenha um par parêntese fechado.
        Então, se nenhum parentêse fechado é encontrado, o parentêse aberto não será modificado
        e o @while@ nunca ficará satisfeito.


        Como você reescreveria este método?  Eu sei como me virar no Ruby, então eu usaria uma expressão
        regular.


        <pre>
         def limpar_murmurios_de( frase )
           unless frase.respond_to? :gsub
             raise ArgumentError, 
               "não posso limpar os múrmurios de um(a) #{ frase.class }"
           end
           frase.gsub( /\([-\w]+\)/, '' )
         end
        </pre>


        Dê o seu melhor quando pensar nos seus.  É muito fácil especialmente pros loops @while@ e @until@
        saírem do controle.  Melhorar usar um iterador.  E nós chegaremos em expressões regulares na hora certa.


        Resumidamente, aqui está o que aprendemos sobre escrever métodos:


        # Não se surpreenda se as pessoas passarem objetos inesperados pros seus métodos.
        Se você não pode maneira algum usar o que te deram, @raise (cause)@ um erro.

        # É falta de educação mudar objetos que são dados aos seus métodos.  Use @dup@ para
        fazer uma cópia.  Ou encontre um método como @gsub@ que automaticamente faz a cópia
        enquanto faz o seu serviço.

        # As chaves podem ser usadas para procurar partes dentro de qualquer objeto @Array@, @Hash@ ou @String@,
        já que estes objetos provém um método @[]@.  E também, já que este objetos provém um método @[]=@,
        as chaves podem ser usadas pra assignment (do lado esquerdo do sinal de igual) to
        change the parts of those objects.

        # Cuidado com loops fujões.  Evite @while@ e @until@ se você puder.
 

        h3. Os Mecanismos do Estereótipo


        !>i/my.daughters.organ-2.gif(Gato vendedor do espaço.)!


        Imediatamente ouve-se um sussuro nas árvores atrás da casa do Paij-ree e acabou que era
        o homem q caíra do céu.  Seu nome era Doug e ele vendia gatos.


        So, just as he comes into to view, when his shadow (and the shadows of the cats tied to his
        foot) obscures the bird on the lawn that we're trying to hit with a racquetball, 
        as he's squeezing a wisp of helium from his big balloon, we shout, "Hello, Doug!"


        E ele diz, "Olá, Gonk-ree!  Olá, Why!"


        Paij-ree checa os bolsos pra ter certeza que ele tem o real-e-vinte-sete que ele vai precisar pra comprar
        comprar os três gatos que ele necessita pra mandar a fornalha abastecida e o parabólica virando. Estes
        gatos cats generate gobs of static once Paij-ree tosses them in the generator, where they'll be
        outnumbered by the giant glass rods, which caress the cats continually-- Mas, espere!  Você reparou
        como how the cat broker called him Gonk-ree?

        
        E ele o chama de Gonk-ree de dia e Gonk-plo de noite.


        Então o sufixo é definitivamente relacionado à luz do sol.  Até onde eu sei, o prefixo indica
        a relação de que chama o Paij-ree.

        
        <pre>
         class String

           # As partes do nome do professor
           # de órgão da minha filha.
           @@silabas = [
             { 'Paij' => 'Pessoal',
               'Gonk' => 'Negócios',
               'Blon' => 'Escravo',
               'Stro' => 'Mestre',
               'Wert' => 'Pai',
               'Onnn' => 'Mãe' },
             { 'ree'  => 'AM',
               'plo'  => 'PM' }
           ]

           # Um método pra determinar o que
           # signfica certos nomes dele.
           def significado_do_nome
             partes = self.split( '-' )
             silabas = @@silabas.dup
             significado = partes.collect do |p|
               silabas.shift[p]
             end
             significado.join( ' ' )
           end

         end
        </pre>


        Agora eu fui bem mais além do que te mostrar apenas código e beyond just showing you sloppy code.  Houve aqui uma grave libertinagem e um crime
        contra a natureza.  Um crime que a maioria das linguagens não permitiriam que você cometesse.  Nós estamos mudando a
        @String@, *uma das classes do núcleo do Ruby*!


        "Eu sei que isto é um pouco perigoso," Eu disse, when I passed this one under Paij-ree's nose.
        "I hope nobody gets hurt."


        "Every Smotchkkiss must taste what this (kep-yo-iko) danger does," he said.  "Dogs and logs
        and swampy bogs (kul-ip), all must be tasted."  And he took a swig of his Beagle Berry
        marsh drink.


        Então o que é que eu estou adicionando à classe @String?@  Duas coisas: uma variável de classe e
        um método.  Um *método de instância* normal.


        Eu gosto de ver a *arroba* como um caracter que signifique *atributo*.  A *arroba dupla*
        stands for *attribute all*.  A class variable.  Todas as instâncias da classe podem olhar
        pra esta váriavel e ela é a mesma pra todas.  A variável @@@silabas@ é um Array
        que agora pode ser usando dentro da classe String.


        O novo método é @significado_do_nome@ e esse novo método pode ser usado com qualquer string.


        bq. @print "Paij-ree".significado_do_nome@ imprime @Pessoal AM@.


        Como você pode ver, Paij-ree é um nome pessoal.  Um nome que os amigos usam nas manhãs.


        Tenha certeza de ter visto a linha de código que usa @self@.  Esta é uma váriavel especial, uma
        variável que representa o objeto cujo método você está chamando.  Para simplificar as coisas um
        pouco, vamos tentar fazer um método que separe uma string pelos hífens.


        <pre>
         class String
           def separar_hifen
             self.split( '-' )
           end
         end
        </pre>


        De novo, aqui está um método que pode ser usando com qualquer string.


        bq. @"Gonk-plo".separar_hifen@ retorna o Array @['Gonk', 'plo']@.


        Usar @self@ marca o começoks the beginning of crossing over into many of the more advanced ideas in Ruby.
        This is definition language.  Você está definindo um método, desenhando ele antes dele ser usado.  Você está
        preparando para a existência de um objeto que use aquele método.  Você está dizendo, "Quando @separar_hifen@ 
        for usado, haverá uma string a qual estaremos separando-hifens.  E @self@ é uma variável especial 
        que faz referência àquela string."


        Ruby is a knockout definition language.  A succulent and brain-splitting discussion is coming your
        way deeper in this book.


        Na maioria das vezes você nao vai precisar usar @self@ explicitamente, já que você pode chamar métodos
        diretamente dentro de outra definição de método.


        <pre>
         class String
           def separar_hifen; split( '-' ); end
         end
        </pre>


        No método @significado_do_nome@, encontre o loop.  Aprender sobre @Array#collect@ é essencial.
        Vamos olhar de perto.


        <pre>
         signif = partes.collect do |p|
           silabas.shift[p]
         end
        </pre>


        A Array @partes@ contém o nome separado.  @['Paij', 'plo']@, por exemplo.  Estamos iterando por
        cada item naquela Array com @collect@.  Mas @collect@ vai uma passo a frente ao que o @each@ faz.  Assim
        como @each@, collect joga cada item pela calha como uma variável de bloco.  E aí, ao término do 
        block, @collect@ *mantém a resposta que o block gives dá e a adiciona em um novo Array*.  O método 
        @collect@ é o jeito perfeito de se fazer um novo Array que é baseado em itens de um Array existente.


        O Doug tem três gatos à venda.  Um custa doze centavos, um sessenta e três centavos, um nove centavos.
        Vamos ver quanto cada gato custaria se nós adicionássemos uma gorjeta de 20%.


        <pre>
         gatosegorjetas = [0.12, 0.63, 0.09].collect { |custogato| custogato + ( custogato * 0.20 ) }
        </pre>


        I say Paij-ree's property is a very charming section of woods when it's not raining cats and Doug.
        For many days, Paij-ree and I camped in tents by the river behind his house, subsisting on smoked
        blackbird and whittling little sleeping indians by the dusklight.  On occassion he would lose
        a game of spades and I knew his mind was distracted, thinking of Endertromb.  All of this
        must have been stirring inside of him for sometime.  I was the first ear he'd ever had.


        "I just came from Ambrose," I said.  "Sort of my own underground home, a place where elves
        strive to perfect animals."


        He mumbled and nodded.  "You can't be (poth-in-oin) part of (in) such things."


        "You think we will fail?"


        "I (preep) have been there before," he said.  And then, he spoke of the Lotteries.


