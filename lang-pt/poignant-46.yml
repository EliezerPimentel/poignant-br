    - >
        Oh, e mais uma coisa sobre o @dup@.  Algumas coisas não podem ser dup'adas.  Números, por exemplo.  
        Símbolos (que se parecem com @:morte@) são identicos quando grafados iguais.  Assim como números.


        Além disso, algumas variáveis especiais: @nil@, @true@, @false@.  Estas são coisas que o Ruby não vai
        te deixar alterar, então não faz sentido copiar mesmo.  Quero dizer, imagine se você pudesse mudar o @false@
        para que seja @true@.  A coisa toda vira uma mentira.


        Talvez o *Aspecto Confuso No. 3* seja um simples.  Estou usando aquelas chaves na string. 
        Estou tratando a como se ela fosse um Array ou Hash.  Eu posso fazer isso.  Porque strings
        têm um método @[]@.


        Quando usadas numa string, as chaves vão extrair parte daquela string.  Again,
        espaço para as pás da empilhadeira. A string é uma longa prateleira the forklift is pulling out a slab
        of the string.


        Dentro das chaves, nós passamos o _index (índice)_.  É a etiqueta que colocamos entre as pás
        onde o trabalhador pode vê-las.  Quando o assunto são strings, podemos usar vários objetos como
        índices.
        

        <pre>
         str = "Uma string é uma longa prateleira de letras e espaços."
         puts str[0]       # imprime 85 (o código do caracter 'U')
         puts str[0..-1]   # imprime 'Uma string é uma longa prateleira de letras e espaços.'
         puts str[1..-2]   # imprime 'ma string é uma longa prateleira de letras e espaços'
         puts str[1, 3]    # imprime 'ma '
         puts str['prateleira'] # imrpime 'shelf'
        </pre>


        Tudo bem, o último *Aspecto Confuso No. 4*: este método pode ser enviado a um loop sem fim.
        Você pode dar uma string para este método que vai fazer com q ele trave e nunca mais volte.
        Dê uma olhada no método.  Você pode jogar um graveto pra travar o loop?


        <pre>
         def limpar_murmurios_de( frase )
           unless frase.respond_to? :include?
             raise ArgumentError, 
              "não posso limpar os múrmurios de um(a) #{ frase.class }"
           end
           frase = frase.dup
           while frase.include? '('
             abre = frase.index( '(' )
             fecha = frase.index( ')', abre )
             frase[abre..fecha] = '' if fecha
           end
           frase
         end
        </pre>


        Aqui, entorte o graveto antes de enfiá-lo.


        <pre>
         graveto = "Aqui está uma ( curva."
         limpar_murmurios_de( graveto )
        </pre>


        Por que o método trava?  Bem, o loop @while@ espera até que todos os parênteses abertos se 
        acabem antes de parar de looping.  E ele só modifica um parêntese aberto que tenha um par parêntese fechado.
        Então, se nenhum parentêse fechado é encontrado, o parentêse aberto não será modificado
        e o @while@ nunca ficará satisfeito.


        Como você reescreveria este método?  Eu sei como me virar no Ruby, então eu usaria uma expressão
        regular.


        <pre>
         def limpar_murmurios_de( frase )
           unless frase.respond_to? :gsub
             raise ArgumentError, 
               "não posso limpar os múrmurios de um(a) #{ frase.class }"
           end
           frase.gsub( /\([-\w]+\)/, '' )
         end
        </pre>


        Do your best to think through your loops.  It's especially easy for @while@ and @until@ loops
        to get out of hand.  Melhorar usar um iterador.  E nós chegaremos em expressões regulares na hora certa.


        Resumidamente, aqui está o que aprendemos sobre escrever métodos:


        # Não se surpreenda se as pessoas passarem objetos inesperados pros seus métodos.
        Se você não If you absolutely can't use what they give you, @raise@ an error.

        # É falta de educação muda objetos que são dados aos seus métodos.  Use @dup@ para
        fazer uma cópia.  Ou encontre um método como @gsub@ que automaticamente faz uma cópia
        enquanto faz seu serviço.

        # As chaves podem ser usadas para procurar partes dentro de qualquer objeto @Array@, @Hash@ ou @String@,
        já que estes objetos provém um método @[]@.  E também, já que este objetos provém um método @[]=@,
        as chaves podem ser usadas pra assignment (do lado esquerdo do sinal de igual) to
        change the parts of those objects.

        # Cuidado com loops fujões.  Evite @while@ e @until@ se você puder.
 

        h3. The Mechanisms of Name-Calling


        !>i/my.daughters.organ-2.gif(Cat salesmen from the sky.)!


        Forthwith there is a rustling in the trees behind Paij-ree's house and it turns out to
        be a man falling from the sky.  His name is Doug and he sells cats.


        So, just as he comes into to view, when his shadow (and the shadows of the cats tied to his
        foot) obscures the bird on the lawn that we're trying to hit with a racquetball, 
        as he's squeezing a wisp of helium from his big balloon, we shout, "Hello, Doug!"


        And he says, "Hello, Gonk-ree!  Hello, Why!"


        Paij-ree checa os bolsos pra ter s to be sure he has the dollar-twenty-seven he'll need in order to
        buy the three cats he'll need to keep the furnace stoked and the satellite dish turning.  These
        cats generate gobs of static once Paij-ree tosses them in the generator, where they'll be
        outnumbered by the giant glass rods, which caress the cats continually-- But, wait!  Did you see
        how the cat broker called him Gonk-ree?

        
        And he calls him Gonk-ree in the morning and Gonk-plo at night.


        So the suffix is definitely subject to the sunlight.  As far as I can tell, the prefix indicates
        the namecaller's relationship to Paij-ree.

        
        <pre>
         class String

           # The parts of my daughter's organ
           # instructor's name.
           @@silabas = [
             { 'Paij' => 'Pessoal',
               'Gonk' => 'Negócios',
               'Blon' => 'Escravo',
               'Stro' => 'Mestre',
               'Wert' => 'Pai',
               'Onnn' => 'Mãe' },
             { 'ree'  => 'AM',
               'plo'  => 'PM' }
           ]

           # A method to determine what a
           # certain name of his means.
           def significado_do_nome
             partes = self.split( '-' )
             silabas = @@silabas.dup
             signif = partes.collect do |p|
               silabas.shift[p]
             end
             signif.join( ' ' )
           end

         end
        </pre>


        Now I've gone beyond just showing you sloppy code.  Here be a grave debauchery and a crime
        against nature.  A crime most languages won't allow you to commit.  We're changing the
        @String@, *one of the core classes of Ruby*!


        "I know this is a bit dangerous," I said, when I passed this one under Paij-ree's nose.
        "I hope nobody gets hurt."


        "Every Smotchkkiss must taste what this (kep-yo-iko) danger does," he said.  "Dogs and logs
        and swampy bogs (kul-ip), all must be tasted."  And he took a swig of his Beagle Berry
        marsh drink.


        So what is it that I'm adding to the @String@ class?  Two things: a class variable and
        a method.  A normal *instance method*.


        I like to look at the *at* symbol as a character meaning *attribute*.  The *double at*
        stands for *attribute all*.  A class variable.  All instances of a class can look at
        this variable and it is the same for all of them.  The @@@syllables@ variable is an
        Array that can now be used inside the String class.


        The new method is @name_significance@ and this new method can be used with any string.


        bq. @print "Paij-ree".name_significance@ prints out @Personal AM@.


        As you can see, Paij-ree is a personal name.  A name friends use in the early hours.


        Make sure you see the line of code which uses @self@.  This is a special variable, a
        variable which represents the object whose method you are calling.  To simplify things
        a bit, let's try making a method which breaks up a string on its dashes.


        <pre>
         class String
           def separar_hifen
             self.split( '-' )
           end
         end
        </pre>


        Again, here's a method which can be used with any string.


        bq. @"Gonk-plo".separar_hifen@ retorna o Array @['Gonk', 'plo']@.


        Usar @self@ marca o começoks the beginning of crossing over into many of the more advanced ideas in Ruby.
        This is definition language.  You're defining a method, designing it before it gets used.  You're
        preparing for the existence of an object which uses that method.  You're saying, "When @dash_split@ 
        gets used, there will be a string at that time which is the one we're dash-splitting.  And @self@ is a 
        special variable which refers to that string."


        Ruby is a knockout definition language.  A succulent and brain-splitting discussion is coming your
        way deeper in this book.


        Na maioria das vezes você nao vai precisar usar @self@ explicitamente, já que você pode chamar métodos
        diretamente dentro de outra definição de método.


        <pre>
         class String
           def separar_hifen; split( '-' ); end
         end
        </pre>


        No método @significado_do_nome@, encontre o loop.  Aprender sobre @Array#collect@ é essencial.
        Vamos olhar de perto.


        <pre>
         signif = partes.collect do |p|
           silabas.shift[p]
         end
        </pre>


        A Array @partes@ contém o nome separado.  @['Paij', 'plo']@, por exemplo.  Estamos iterando por
        cada item naquela Array com @collect@.  Mas @collect@ vai uma passo a frente ao que o @each@ faz.  Assim
        como @each@, collect joga cada item pela calha como uma variável de bloco.  E aí, ao término do 
        block, @collect@ *mantém a resposta que o block gives dá e a adiciona em um novo Array*.  O método 
        @collect@ é o jeito perfeito de se fazer um novo Array que é baseado em itens de um Array existente.


        O Doug tem três gatos à venda.  Um custa doze centavos, um sessenta e três centavos, um nove centavos.
        Vamos ver quanto cada gato custaria se nós adicionássemos uma gorjeta de 20%.


        <pre>
         gatosegorjetas = [0.12, 0.63, 0.09].collect { |custogato| custogato + ( custogato * 0.20 ) }
        </pre>


        I say Paij-ree's property is a very charming section of woods when it's not raining cats and Doug.
        For many days, Paij-ree and I camped in tents by the river behind his house, subsisting on smoked
        blackbird and whittling little sleeping indians by the dusklight.  On occassion he would lose
        a game of spades and I knew his mind was distracted, thinking of Endertromb.  All of this
        must have been stirring inside of him for sometime.  I was the first ear he'd ever had.


        "I just came from Ambrose," I said.  "Sort of my own underground home, a place where elves
        strive to perfect animals."


        He mumbled and nodded.  "You can't be (poth-in-oin) part of (in) such things."


        "You think we will fail?"


        "I (preep) have been there before," he said.  And then, he spoke of the Lotteries.


