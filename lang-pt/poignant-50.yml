    - O Roubo do Capitão da Loteria: >


        !>i/my.daughters.organ-3.gif(A tubulação e as misturas das loterias.)!


        E agora, as histórias de Paij-ree sobre as Loterias.


        Em Endertromb, o pai do organista inventou a loteria.  A idéia veio enquanto ele estava
        rezando para o Escavador Dosh.


        Escavador Dosh é uma espécie de Deus para eles.  Mas dez vezes mais
        assustador.  Este cara cavou um túnel infinitamente profundo através do planeta
        e saiu morto. Mas ele não está realmente morto.  Ele na verdade está apenas _um segundo_
        atrás deles. E ele come tempo.


        É meio complicado, porque Escavador Dosh mata gente.  Mas
        acho que se você faz o que ele diz, não é tão ruim.  Talvez falarei sobre isso
        depois.  É tão difícil falar sobre, pois é tão assustador e ainda assim um de
        meus amigos realmente acredita na coisa toda.  Isso me engasga -- não como se eu
        estivesse chorando, mas como se eu estivesse engasgado.


        De qualquer jeito, uma vez enquanto rezava, três números vieram ao pai de Paij-ree.


        Ele então perguntou à sua mente, "O que são esses números?"


        E sua mente mostrou um pequeno vídeo clipe dele vendendo todos os tipos de números.  E,
        por anos e anos, viajando e vendendo números.


        E ele perguntou a seu cérebro, "Pessoas vão comprar números?"


        E seu cérebro disse, "Se eles comprarem os três números certos, dê-lhes um prêmio."


        Foi quando ele se imaginou lançando de um salto com ski e fazendo chover prêmios sobre as pessoas
        Não havia dúvida: ele seria um ícone.


        Então ele foi e fez como seu cérebro disse, e vendeu números.  A loteria simples do pai
        consistia em três números únicos, escolhidos de um conjunto de 25 números.


        <pre>
         class BilheteLoteria

           INTERVALO_NUMERICO = 1..25

           attr_reader :numeros_escolhidos, :data_compra

           def initialize( *numeros_escolhidos )
             if numeros_escolhidos.length != 3
               raise ArgumentError, "três números devem ser escolhidos"
             elsif numeros_escolhidos.uniq.length != 3
               raise ArgumentError, "os três números escolhidos devem ser distintos"
             elsif numeros_escolhidos.detect { |p| not INTERVALO_NUMERICO === p }
               raise ArgumentError, "os três números escolhidos devem estar entre 1 e 25."
             end
             @numeros_escolhidos = numeros_escolhidos
             @data_compra = Time.now
           end

         end
        </pre>


        Sim, a classe @BilheteLoteria@ contém os três números (@@numeros_escolhidos@) e o
        momento em que o bilhete foi adquirido (@@data_compra@).  O intervalo de números
        permitidos (de *um* a *vinte e cinco*) é mantido na constante @INTERVALO_NUMERICO@.


        O método @initialize@ pode ter qualquer número de argumentos passados. O *asterisco*
        no argumento @numeros_escolhidos@ significa que *quaisquer argumentos serão passados
        como um Array*.  Ter os argumentos em um Array significa que métodos como @uniq@ e
        @detect@ podem ser usados juntos aos argumentos.


        Esta classe contém duas definições: o método de definição (@def@) e um
        de definição de atributos (@attr_reader@).  Ambos são, realmente, *apenas métodos de
        definição*.


        O @attr_reader@ é um atalho idêntico à escrever o este código Ruby:


        <pre>
         class BilheteLoteria
           def numeros_escolhidos; @numeros_escolhidos; end
           def data_compra; @data_compra; end
         end
        </pre>


        Atributos são métodos empacotados para variáveis de instância (assim como
        @@numeros_escolhidos@) que podem ser usados *fora da própria classe*.  O pai do
        Paij-ree queria codificar uma máquina que pudesse ler números e a data da
        compra do bilhete.  Para fazer isso, estas variáveis de instância devem ser expostas.


        Vamos criar um bilhete aleatório e ler os números de volta:


        <pre>
         bilhete = BilheteLoteria.new( rand( 25 ) + 1,
                     rand( 25 ) + 1, rand( 25 ) + 1 )
         p bilhete.numeros_escolhidos
        </pre>


        Executando o código acima, eu apenas pego: @[23, 14, 20]@.  Você receberá um
        erro se acontecer dos dois números aleatórios serem idênticos.


        Entretanto, eu não posso mudar os números escolhidos no bilhete de loteria de
        fora da classe.


        <pre>
         bilhete.numeros_escolhidos = [2, 6, 19]
        </pre>


        Eu receberei um erro: @undefined method `numeros_escolhidos=`@
        Isto porque @attr_reader@ somente adiciona um método de *leitura*, não um método
        de escrita.  Embora isso seja bom.  Nós não queremos mudanças nos números ou na
        data.


        Então, os bilhetes são _objetos_.  Instâncias da classe @BilheteLoteria@.  Faça
        um bilhete com @BilheteLoteria.new@.  Cada bilhete tem as suas variáveis de instância
        @@numeros_escolhidos@ e @@data_compra@.


        O capitão loteria teria necessidade de gerar três números aleatórios no
        encerramento do sorteio, por isso vamos acrescentar um método de classe
        conveniente para geração aleatória de bilhetes.


        <pre>
         class BilheteLoteria
           def self.novo_aleatorio
             new( rand( 25 ) + 1, rand( 25 ) + 1, rand( 25 ) + 1 )
           end
         end
        </pre>


        Oh, não.  Mas nós temos um estúpido erro que aparece quando dois dos números
        aleatórios são idênticos.  Se dois números são iguais, o @initialize@ lança um
        @ArgumentError@.


        O truque é voltar e reiniciar o método se um erro acontecer.
        Nós podemos usar o @rescue@ (_resgate_) do Ruby para apanhar o erro e @redo@
        (_refazer_) o método do início.


        <pre>
         class BilheteLoteria
           def self.novo_aleatorio
             new( rand( 25 ) + 1, rand( 25 ) + 1, rand( 25 ) + 1 )
           rescue ArgumentError
             redo
           end
         end
        </pre>


        Melhor.  Pode demorar duas vezes mais para os números cairem juntos
        corretamente, mas cairão.  O tempo de espera fará o suspense, não?


        O capitão loteria mantém um registro de todos que compraram bilhetes,
        junto com os números sorteados.


        <pre>
         class SorteioLoteria
           @@bilhetes = {}
           def SorteioLoteria.comprado_por( cliente, *bilhetes )
             unless @@bilhetes.has_key?( cliente )
               @@bilhetes[cliente] = []
             end
             @@bilhetes[cliente] += bilhetes
           end
         end
        </pre>


        Yal-dal-rip-sip foi o primeiro cliente.


        <pre>
         SorteioLoteria.comprado_por 'Yal-dal-rip-sip',
             BilheteLoteria.new( 12, 6, 19 ),
             BilheteLoteria.new( 5, 1, 3 ),
             BilheteLoteria.new( 24, 6, 8 )
        </pre>


        Quando chega a hora de sortear a loteria, o pai do Paij-ree (o capitão loteria)
        adiciona um bit de código para selecionar aleatoriamente os números.


        <pre>
         class BilheteLoteria
           def pontuacao( final )
             contador = 0
             final.numeros_escolhidos.each do |nota|
               contador += 1 if numeros_escolhidos.include? nota
             end
             contador
           end
         end
        </pre>


        O método @pontuacao@ compara um @BilheteLoteria@ com um bilhete aleatório,
        o qual representa a combinação vencedora.  O bilhete aleatório é passado
        através da variável @final@.  O bilhete recupera um ponto para todo número
        vencedor.  A pontuação final é retornada pelo método @pontuacao@.


        <pre>
         irb> bilhete  = BilheteLoteria.new( 2, 5, 19 )
         irb> vencedor = BilheteLoteria.new( 4, 5, 19 )
         irb> bilhete.pontuacao( vencedor )
           => 2
        </pre>


        Com o tempo você perceberá o quão brilhante Paij-ree é (ou era). Seu pai o
        encarregou de conduzir a loteria por ele, e a demanda por bilhetes só crescia,
        a medida que o dia passava.  Você consegue imaginar o jovem Paij-ree - em seu
        terno pomposo - brincando com eláticos de dinheiro com seus dedos jovens, em
        meio à reunião da empresa na qual propôs a última parte do sistema?  Com certeza,
        quando se levantou, seu pai falou tudo para ele, mas ele se apoiou ligou o
        projetor e explicou tudo apontando com as mãos.

 
        <pre>
         class << SorteioLoteria
           def jogo
             final = BilheteLoteria.novo_aleatorio
             vencedores = {}
             @@bilhetes.each do |comprador, lista_bilhetes|
               lista_bilhetes.each do |bilhete|
                 pontuacao = bilhete.pontuacao( final )
                 next if pontuacao.zero?
                 vencedores[comprador] ||= []
                 vencedores[comprador] << [ bilhete, pontuacao ]
               end
             end
             @@bilhetes.clear
             vencedores
           end
         end
        </pre>


        Os sócios de seu pai ficaram atordoados.  O que era aquilo?  (Paij-ree
        sabia que era apenas a definição de um método de classe -- eles se
        sentiram completamente desmoralizados quando ele disse isso).  Eles não
        conseguiam entender as *duas setas para esquerda*.  Sim, era um
        concatenador, mas o que estaria ele fazendo em meio à definição da classe?
        

        Crianças, pensava Paij-ree, embora levantasse a auto-estima dos sócios.
        Ele era apenas uma criança e crianças são duras como uma parede de tijolos.


        O operador @<<@ permite a você alterar a definição de um objeto.
        Paij-ree simplesmente havia usado a classe @SorteioLoteria@, e o método
        dele, @jogo@, seria um método de instância normal.  Mas, uma vez que usou o
        operador @<<@, o método @jogo@ será adicionado diretamente à classe,
        como um método de classe.


        Quando você viu @class << objeto@, acredite em seu coração, _eu estou adicionando
        diretamente para a definição de @objeto@._


        O instrutor do setor de desenvolvimento também lançou um truque na sintaxe digno
        de ser examinado.


        <pre>
         vencedores[comprador] ||= []
         vencedores[comprador] << [ bilhete, pontuacao ]
        </pre>


        A sintaxe @||=@ é um atalho.


        <pre>
         vendendores[comprador] = vencedores[comprador] || []
        </pre>


        O *pipe duplo* é um *ou* lógico.  Coloque @vendendores[comprador]@ igual a
        @vencedores[comprador]@ ou, se @vencedores[comprador]@ é nulo, ajuste-o para @[]@.  Este
        atalho é um pouco estranho,  mas se você puder abrir sua mente, ele é um bom método para
        economizar tempo.  Você está se certificando que uma variável está inicializada antes de
        usá-la.


        <pre>
         irb> SorteioLoteria.jogo.each do |vencedor, bilhetes|
         irb>   puts vencedor + " ganhou com " + bilhetes.length + " bilhete(s)!"
         irb>   bilhetes.each do |bilhete, pontuacao|
         irb>     puts "\t" + bilhete.numeros_escolhidos.join( ', ' ) + ": " + pontuacao
         irb>   end
         irb> end

         Gram-yol ganhou com 2 bilhetes(s)!
             25, 14, 33: 1
             12, 11, 29: 1
         Tarker-azain ganhou com 2 bilhetes(s)!
             13, 15, 29: 2
         Bramlor-exxon ganhou com 2 bilhetes(s)!
             2, 6, 14: 1
        </pre>


        Mas estes dias de inocência não continuaram para Paij-ree e seu pai.  Seu pai, muitas vezes,
        se negava em lavar seu uniforme e acabou contraindo uma doença de mofo nos seus ombros.  A
        doença afetou gadualmente seu equilíbrio e seu senso de direção.


        Seu pai ainda tentou futilmente manter os negócios funcionando.  Ele rodou a cidade, algumas
        vezes andando, de forma deplorável, passo-a-passo sobre os paralelepípedos, muitas vezes
        tateando as paredes, contando os tijolos para o salão dos matemáticos e a estação dos cocheiros,
        onde ele empurraria bilhetes para os transeuntes, que o perseguiam o esbofetavam
        com longas betterabas molhadas.  Mais tarde, Paij-ree o encontraria num canto, seu sangue correndo
        nos esgotos da cidade junto aos caldos da escuridão, beterrabas respingantes, cujo caldo entrara
        abusadamente em suas veias e doeu e coagulou e se incandesceu violentamente como um denso exército
        de luzes de freio superando postos de pedágio.

        h3. Uma Palavra sobre Accessors (_Acessores_) (Por que Eu Amo Você e Espero Pelo Seu Sucesso e
        Meu Cabelo está no Fim Por Causa Disso e Sonhos Realmente se Tornam Realidade)
        

        Anteriormente, Eu mencionei que @attr_reader@ adiciona métodos *reader*(_leitores_), mas não métodos *writer*
        (_escritores_).


        <pre>
         irb> bilhete = BilheteLoteria.new
         irb> bilhete.numeros_escolhidos = 3
         NoMethodError: undefined method `numeros_escolhidos=' for #<BilheteLoteria:0xb7d49110>
        </pre>


        O que está correto neste caso, visto que o pai de Paij-ree não queria que nenhum número
        fosso modificado após a compra do bilhete.  Se estivessemos interessados em ter
        variáveis de instância que tivessem *ambos leitores e escritores*, nós usaríamos
        @attr_accessor@.


        <pre>
         class BilheteLoteria
           attr_accessor :numeros_escolhidos, :data_compra
         end
        </pre>


        Que faz exatemente o mesmo que esse código mais longo:


        <pre>
         class BilheteLoteria
           def numeros_escolhidos;       @numeros_escolhidos;       end
           def numeros_escolhidos=(var); @numeros_escolhidos = var; end
           def data_compra;              @data_compra;              end
           def data_compra=(var);        @data_compra = var;        end
         end
        </pre>


        Gatos me mordam! Olhem para estes métodos escritores por um momento.  Eles são os métodos nomeados
        @numeros_escolhidos=@ e @data_compra=@. Estes métodos *interceptam a atribuição externa* para variáveis
        de instância.  Geralmente você apenas deixará @attr_reader@ ou @attr_accessor@ (ou talvez até mesmo 
        @attr_writer@) fazer o trabalho para você. Em outras circusntâncias, pode querer colocar você mesmo vigiar a portaria,
        checando as variáveis detalhadamente.


        <pre>
         class SkatingContest
           def o_vencedor; @o_vencedor; end
           def o_vencedor=( nome )
             unless nome.respond_to? :to_str
               raise ArgumentError, "O nome do vencedor deve ser uma String,
                 não um prooblema matemático ou uma lista de nomes ou qualquer ou
                 coisa parecida."
             end
             @o_vencedor = nome
           end
         end
        </pre>


        Na maioria das vezes você não usára isso.  Porém, a medida que caminharmos pelas lições, descobrirá
        que Ruby tem muitas escotilhas de saída e várias vielas em que você pode enfiar-se e codificar de outras maneiras.
        Estou também lhe preparando para a metaprogramação que, caso você possa farejar este dragão, está
        ameaçadoramente próxima.

