    - O Roubo do Capitão Loteria: >


        !>i/my.daughters.organ-3.gif(Os tubos e misturas das loterias.)!


        E agora, as histórias das Loterias Paij-ree.


        Em Endertromb, o pai do organista inventou a loteria.  A idéia surgiu quando ele estava
        rezando para o Escavador Dosh.


        Escavador Dosh é uma espécie de Deus para eles.  Mas dez vezes mais
        assustador.  Esse cara cava um túnel infinitamente profundo através do planeta
        e sai morto.  Mas ele não está realmente morto.  Ele está realmente _um segundo_
        atrás deles.  E ele come tempo.


        É mais ou menos complicado, porque o Escavador Dosh mata totalmente as pessoas.  Mas
        eu convido você a fazer o que ele diz, ele não é tão mal.  Talvez eu fale sobre isso
        mais tarde.  É um tal de fala sobre dor, porque isso é tão assustador e ainda um dos
        meus amigos realmente acredita em tudo isso.  Eu fico meio que chocado -- não que eu
        esteja chorando, estou apenas surpreso.


        De qualquer forma, enquanto rezava, três números vieram para o pai do Paij-ree.


        Ele então se perguntou. "O que são esses números?"


        E sua mente passou um pequeno vídeo clip dele vendendo todos os tipos de números.  E,
        por anos e anos, viajando e vendendo números.


        E ele perguntou ao seu cérebro, "Pessoas comprarão números?"


        E seu cérebro disse, "Se eles comprarem os três números corretos, dê a eles um prêmio."


        Pelo que ele mesmo imaginava um salto alto com um ski e jogando neve nas pessoas
        presentes.  Não questione: ele seria um ícone.


        Então ele foi e fez o que seu cérebro disse e vendeu números. O pai da loteria
        simples consistia em três únicos números, retirados de um conjunto de 25 números.


        <pre>
         class BilheteLoteria

           INTERVALO_NUMERICO = 1..25

           attr_reader :numeros_escolhidos, :data_compra

           def initialize( *numeros_escolhidos )
             if numeros_escolhidos.length != 3
               raise ArgumentError, "três números devem ser escolhidos"
             elsif numeros_escolhidos.uniq.length != 3
               raise ArgumentError, "os três escolhidos devem ser diferentes"
             elsif numeros_escolhidos.detect { |p| not INTERVALO_NUMERICO === p }
               raise ArgumentError, "os três escolhidos devem ser números entre 1 e 25."
             end
             @numeros_escolhidos = numeros_escolhidos
             @data_compra = Time.now
           end

         end
        </pre>


        Sim, a classe @BilheteLoteria@ contém os três números (@@numeros_escolhidos@) e o
        momento em que o bilhete foi adquirido (@@data_compra@).  O intervalo de números
        permitidos (de *um* a *vinte e cinco*) é mantido na constante @INTERVALO_NUMERICO@.


        O método @initialize@ pode ter qualquer número de argumentos passados. O *asterisco*
        no argumento @numeros_escolhidos@ significa que *quaisquer argumentos serão passados
        como um Array*.  Ter os argumentos em um Array significa que métodos como @uniq@ e
        @detect@ podem ser usados juntos aos argumentos.


        Esta classe contém duas definições: o método de definição (@def@) e um
        de definição de atributos (@attr_reader@).  Ambos são, realmente, *apenas métodos de
        definição*.


        O @attr_reader@ é um atalho idêntico à escrever o este código Ruby:


        <pre>
         class BilheteLoteria
           def numeros_escolhidos; @numeros_escolhidos; end
           def data_compra; @data_compra; end
         end
        </pre>


        Atributos são métodos empacotados para variáveis de instância (assim como
        @@numeros_escolhidos@) que podem ser usados *fora da própria classe*.  O pai do
        Paij-ree queria codificar uma máquina que pudesse ler números e a data da
        compra do bilhete.  Para fazer isso, estas variáveis de instância devem ser expostas.


        Vamos criar um bilhete aleatório e ler os números de volta:


        <pre>
         bilhete = BilheteLoteria.new( rand( 25 ) + 1,
                     rand( 25 ) + 1, rand( 25 ) + 1 )
         p bilhete.numeros_escolhidos
        </pre>


        Executando o código acima, eu apenas pego: @[23, 14, 20]@.  Você receberá um
        erro se acontecer dos dois números aleatórios serem idênticos.


        Entretanto, eu não posso mudar os números escolhidos no bilhete de loteria de
        fora da classe.


        <pre>
         bilhete.numeros_escolhidos = [2, 6, 19]
        </pre>


        Eu receberei um erro: @undefined method `numeros_escolhidos=`@
        Isto porque @attr_reader@ somente adiciona um método de *leitura*, não um método
        de escrita.  Embora isso seja bom.  Nós não queremos mudanças nos números ou na
        data.


        Então, os bilhetes são _objetos_.  Instâncias da classe @BilheteLoteria@.  Faça
        um bilhete com @BilheteLoteria.new@.  Cada bilhete tem as suas variáveis de instância
        @@numeros_escolhidos@ e @@data_compra@.


        O capitão loteria teria necessidade de gerar três números aleatórios no
        encerramento do sorteio, por isso vamos acrescentar um método de classe
        conveniente para geração aleatória de bilhetes.


        <pre>
         class BilheteLoteria
           def self.novo_aleatorio
             new( rand( 25 ) + 1, rand( 25 ) + 1, rand( 25 ) + 1 )
           end
         end
        </pre>


        Oh, não.  Mas nós temos um estúpido erro que aparece quando dois dos números
        aleatórios são idênticos.  Se dois números são iguais, o @initialize@ lança um
        @ArgumentError@.


        O truque é voltar e reiniciar o método se um erro acontecer.
        Nós podemos usar o @rescue@ (_resgate_) do Ruby para apanhar o erro e @redo@
        (_refazer_) o método do início.


        <pre>
         class BilheteLoteria
           def self.novo_aleatorio
             new( rand( 25 ) + 1, rand( 25 ) + 1, rand( 25 ) + 1 )
           rescue ArgumentError
             redo
           end
         end
        </pre>


        Melhor.  Pode demorar duas vezes mais para os números cairem juntos
        corretamente, mas cairão.  O tempo de espera fará o suspense, não?


        O capitão loteria mantém um registro de todos que compraram bilhetes,
        junto com os números sorteados.


        <pre>
         class SorteioLoteria
           @@bilhetes = {}
           def SorteioLoteria.comprado_por( cliente, *bilhetes )
             unless @@bilhetes.has_key?( cliente )
               @@bilhetes[cliente] = []
             end
             @@bilhetes[cliente] += bilhetes
           end
         end
        </pre>


        Yal-dal-rip-sip foi o primeiro cliente.


        <pre>
         SorteioLoteria.comprado_por 'Yal-dal-rip-sip',
             BilheteLoteria.new( 12, 6, 19 ),
             BilheteLoteria.new( 5, 1, 3 ),
             BilheteLoteria.new( 24, 6, 8 )
        </pre>


        Quando chega a hora de sortear a loteria, o pai do Paij-ree (o capitão loteria)
        adiciona um bit de código para selecionar aleatoriamente os números.


        <pre>
         class BilheteLoteria
           def pontuacao( final )
             contador = 0
             final.numeros_escolhidos.each do |nota|
               contador += 1 if numeros_escolhidos.include? nota
             end
             contador
           end
         end
        </pre>


        O método @pontuacao@ compara um @BilheteLoteria@ com um bilhete aleatório,
        o qual representa a combinação vencedora.  O bilhete aleatório é passado
        através da variável @final@.  O bilhete recupera um ponto para todo número
        vencedor.  A pontuação final é retornada pelo método @pontuacao@.


        <pre>
         irb> bilhete  = BilheteLoteria.new( 2, 5, 19 )
         irb> vencedor = BilheteLoteria.new( 4, 5, 19 )
         irb> bilhete.pontuacao( vencedor )
           => 2
        </pre>


        Com o tempo você perceberá o quão brilhante Paij-ree é (ou era). Seu pai o
        encarregou de conduzir a loteria por ele, e a demanda por bilhetes só crescia,
        à medida que o dia passava.  Você consegue imaginar o jovem Paij-ree - em seu
        terno pomposo - brincando com eláticos de dinheiro com seus dedos jovens, em
        meio à reunião da empresa na qual propôs a última parte do sistema?  Com certeza,
        quando se levantou, seu pai falou tudo para ele, mas ele se apoiou ligou o
        projetor e explicou tudo apontando com as mãos.

 
        <pre>
         class << SorteioLoteria
           def jogo
             final = BilheteLoteria.novo_aleatorio
             vencedores = {}
             @@bilhetes.each do |comprador, lista_bilhetes|
               lista_bilhetes.each do |bilhete|
                 pontuacao = bilhete.pontuacao( final )
                 next if pontuacao.zero?
                 vencedores[comprador] ||= []
                 vencedores[comprador] << [ bilhete, pontuacao ]
               end
             end
             @@bilhetes.clear
             vencedores
           end
         end
        </pre>


        Os sócios de seu pai ficaram atordoados.  O que era aquilo?  (Paij-ree
        sabia que era apenas a definição de um método de classe -- eles se
        sentiram completamente desmoralizados quando ele disse isso).  Eles não
        conseguiam entender as *duas setas para esquerda*.  Sim, era um
        concatenador, mas o que estaria ele fazendo em meio à definição da classe?
        

        Crianças, pensava Paij-ree, embora levantasse a auto-estima dos sócios.
        Ele era apenas uma criança e crianças são duras como uma parede de tijolos.


        O operador @<<@ permite à você alterar a definição de um objeto.
        Paij-ree simplesmente havia usado a classe @SorteioLoteria@, e o método
        dele, @jogo@, seria um método de instância normal.  Mas, uma vez que usou o
        operador @<<@, o método @jogo@ será adicionado diretamente à classe,
        como um método de classe.


        Quando você viu @class << objeto@, acredite em seu coração, _eu estou adicionando
        diretamente para a definição de @objeto@._


        O instrutor do setor de desenvolvimento também lançou um truque na sintaxe digno
        de ser examinado.


        <pre>
         vencedores[comprador] ||= []
         vencedores[comprador] << [ bilhete, pontuacao ]
        </pre>


        A sintaxe @||=@ é um atalho.


        <pre>
         vendendores[comprador] = vencedores[comprador] || []
        </pre>


        O *pipe duplo* é um *ou* lógico.  Coloque @vendendores[comprador]@ igual a
        @vencedores[comprador]@ ou, se @vencedores[comprador]@ é nulo, ajuste-o para @[]@.  Este
        atalho é um pouco estranho,  mas se você puder abrir sua mente, ele é um bom método para
        economizar tempo.  Você está se certificando que uma variável está inicializada antes de
        usá-la.


        <pre>
         irb> SorteioLoteria.jogo.each do |vencedor, bilhetes|
         irb>   puts vencedor + " ganhou com " + bilhetes.length + " bilhete(s)!"
         irb>   bilhetes.each do |bilhete, pontuacao|
         irb>     puts "\t" + bilhete.numeros_escolhidos.join( ', ' ) + ": " + pontuacao
         irb>   end
         irb> end

         Gram-yol ganhou com 2 bilhetes(s)!
             25, 14, 33: 1
             12, 11, 29: 1
         Tarker-azain ganhou com 2 bilhetes(s)!
             13, 15, 29: 2
         Bramlor-exxon ganhou com 2 bilhetes(s)!
             2, 6, 14: 1
        </pre>


        Mas estes dias de inocência não continuaram para Paij-ree e seu pai.  Seu pai, muitas vezes,
        se negava em lavar seu uniforme e acabou contraíndo uma doença de mofo nos seus ombros.  A
        doença afetou gadualmente seu equilíbrio e seu senso de direção.


        Seu pai ainda tentou futilmente manter os negócios funcionando.  Ele rodou a cidade, algumas
        vezes andando, de forma deplorável, passo-a-passo sobre os paralelepípedos, muitas vezes
        tateando as paredes, contando os tijolos para o salão dos matemáticos e estação dos cocheiros.


        His father still futilely attempted to keep the business running.  He spiraled through the
        city, sometimes tumbling leg-over-leg down the cobbled stone, most often slowly feeling the walls,
        counting bricks to the math parlours and coachmen stations, <****> where he would thrust tickets
        at the bystanders, who hounded him and slapped him away with long, wet beets.  Later, Paij-ree
        would find him in a corner, his blood running into the city drains alongside the juices of the
        dark, splattered beets, which juice weaseled its way up into his veins and stung and clotted
        and glowed fiercely like a congested army of brake lights fighting their way through toll bridges.


        h3. A Word About Accessors (Because I Love You and I Hope For Your Success and My Hair is On End
        About This and Dreams Really Do Come True)
        

        Earlier, I mentioned that @attr_reader@ adds *reader* methods, but not *writer* methods.


        <pre>
         irb> bilhete = BilheteLoteria.new
         irb> bilhete.numeros_escolhidos = 3
         NoMethodError: undefined method `numeros_escolhidos=' for #<BilheteLoteria:0xb7d49110>
        </pre>


        Which is okay in this case, since Paij-ree's father didn't want the numbers to be
        changed after the ticket was bought.  If we were interested in having instance
        variables which had *both readers and writers*, we would use @attr_accessor@.


        <pre>
         class BilheteLoteria
           attr_accessor :numeros_escolhidos, :data_compra
         end
        </pre>


        Which is exactly the same as this lengthier code:


        <pre>
         class BilheteLoteria
           def numeros_escolhidos;       @numeros_escolhidos;       end
           def numeros_escolhidos=(var); @numeros_escolhidos = var; end
           def data_compra;              @data_compra;              end
           def data_compra=(var);        @data_compra = var;        end
         end
        </pre>


        Holy cats!  Look at those writer methods for a moment.  They are the methods named
        @picks=@ and @purchased=@.  These methods *intercept outside assignment* to instance variables.
        Usually you will just let @attr_reader@ or @attr_accessor@ (or even perhaps @attr_writer@)
        do the work for you.
        Other times you may want to put a guard at the door yourself, checking variables in closer
        detail.


        <pre>
         class SkatingContest
           def o_vencedor; @o_vencedor; end
           def o_vencedor=( nome )
             unless nome.respond_to? :to_str
               raise ArgumentError, "O nome do vencedor deve ser uma String,
                 não um prooblema matemático ou uma lista de nomes ou qualquer ou
                 coisa parecida."
             end
             @o_vencedor = nome
           end
         end
        </pre>


        Most of the time you won't use this.  But, as we move along through your lessons, you'll find that
        Ruby has lots of escape hatches and alley ways you can sneak into and hack code into.  I'm also
        preparing you for metaprogramming, which, if you can smell that dragon, is ominously near.

